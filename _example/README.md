# Example of Standard Library Router Generator

1. Create routing configuration file as `router.go`
    ```go
    // Copyright (c) 2020 Tetsu Takizawa
    
    //+build stdrouter
    
    // The build tag makes sure the stub is not built in the final build.
    package main
    
    import (
    	"net/http"
    
    	"github.com/tetsuzawa/stdrouter"
    	"github.com/tetsuzawa/stdrouter/_example/handler"
    )
    
    // NewHandler creates a http router. It passes HTTP requests to the function.
    func NewRouter() http.Handler {
    	r := stdrouter.NewRouter()
    	r.HandleFunc("/", http.MethodGet, handler.GetRoot)
    	r.HandleFunc("/api", http.MethodGet, handler.GetAPIRoot)
    	r.HandleFunc("/api/users", http.MethodGet, handler.GetUsers)
    	r.HandleFunc("/api/products", http.MethodGet, handler.GetProducts)
    	r.HandleFunc("/api/products", http.MethodPost, handler.CreateProducts)
    	r.HandleFunc("/api/users/create", http.MethodPost, handler.CreateUser)
    	r.HandleFunc("/api/users/:user_id", http.MethodGet, handler.GetUser)
    	r.HandleFunc("/api/users/:user_id", http.MethodPatch, handler.UpdateUser)
    	r.HandleFunc("/api/users/:user_id", http.MethodDelete, handler.DeleteUser)
    	r.HandleFunc("/api/users/:user_id/posts", http.MethodGet, handler.GetPosts)
    	r.HandleFunc("/api/users/:user_id/profile", http.MethodGet, handler.GetUser)
    	r.HandleFunc("/api/users/:user_id/posts/:post_id", http.MethodGet, handler.GetPost)
    	r.HandleFunc("/api/users/:user_id/posts/:post_id/aaa", http.MethodGet, handler.GetPost)
    	r.HandleFunc("/api/users/:user_id/posts/:post_id/aaa/bbb", http.MethodGet, handler.GetPost)
    	r.HandleNotFound(handler.NotFoundHandler)
    	r.HandleMethodNotAllowed(handler.MethodNotAllowedHandler)
    	/*
    		...
    	*/
    	return r
    }
    ```

2. Run `stdrouter` in the same directory as `router.go`
   ```shell script
    $ stdrouter
    ```
3. `router_gen.go` will be created. This is the implementation of router.
   ```go
   // Code generated by Standard Library Router Generator; DO NOT EDIT"
   
   //go:generate stdrouter
   //+build !stdrouter
   
   package main
   
   import (
   	"github.com/tetsuzawa/stdrouter/_example/handler"
   	"net/http"
   	"path"
   	"strings"
   )
   
   type Router struct{}
   
   func NewRouter() http.Handler {
   	r := &Router{}
   	return r
   }
   
   func (router *Router) ServeHTTP(w http.ResponseWriter, r *http.Request) {
   	handleBase(w, r, r.URL.Path)
   }
   
   func handleBase(w http.ResponseWriter, r *http.Request, p string) {
   	endpoint, p := SeparatePath(p, 3)
   	switch endpoint {
   	case "/":
   		switch r.Method {
   		case http.MethodGet:
   			handler.GetRoot(w, r)
   		default:
   			handler.MethodNotAllowedHandler(w, r)
   		}
   
   	case "/api":
   		switch r.Method {
   		case http.MethodGet:
   			handler.GetAPIRoot(w, r)
   		default:
   			handler.MethodNotAllowedHandler(w, r)
   		}
   
   	case "/api/users":
   		switch r.Method {
   		case http.MethodGet:
   			handler.GetUsers(w, r)
   		default:
   			handler.MethodNotAllowedHandler(w, r)
   		}
   
   	case "/api/products":
   		switch r.Method {
   		case http.MethodGet:
   			handler.GetProducts(w, r)
   		case http.MethodPost:
   			handler.CreateProducts(w, r)
   		default:
   			handler.MethodNotAllowedHandler(w, r)
   		}
   
   	case "/api/users/create":
   		switch r.Method {
   		case http.MethodPost:
   			handler.CreateUser(w, r)
   		default:
   			handler.MethodNotAllowedHandler(w, r)
   		}
   
   	default:
   		endpoint, param := SeparatePath(endpoint, 2)
   		if endpoint == "/api/users" {
   			handleUserId(w, r, p, param[1:])
   		} else {
   			handler.NotFoundHandler(w, r)
   		}
   
   	}
   
   }
   
   func handleUserId(w http.ResponseWriter, r *http.Request, p string, userId string) {
   	endpoint, p := SeparatePath(p, 2)
   	switch endpoint {
   	case "/":
   		switch r.Method {
   		case http.MethodGet:
   			handler.GetUser(w, r, userId)
   		case http.MethodPatch:
   			handler.UpdateUser(w, r, userId)
   		case http.MethodDelete:
   			handler.DeleteUser(w, r, userId)
   		default:
   			handler.MethodNotAllowedHandler(w, r)
   		}
   
   	case "/posts":
   		switch r.Method {
   		case http.MethodGet:
   			handler.GetPosts(w, r, userId)
   		default:
   			handler.MethodNotAllowedHandler(w, r)
   		}
   
   	case "/profile":
   		switch r.Method {
   		case http.MethodGet:
   			handler.GetUser(w, r, userId)
   		default:
   			handler.MethodNotAllowedHandler(w, r)
   		}
   
   	default:
   		endpoint, param := SeparatePath(endpoint, 1)
   		if endpoint == "/posts" {
   			handlePostId(w, r, p, userId, param[1:])
   		} else {
   			handler.NotFoundHandler(w, r)
   		}
   
   	}
   
   }
   
   func handlePostId(w http.ResponseWriter, r *http.Request, p string, userId string, postId string) {
   	endpoint, p := SeparatePath(p, 2)
   	switch endpoint {
   	case "/":
   		switch r.Method {
   		case http.MethodGet:
   			handler.GetPost(w, r, userId, postId)
   		default:
   			handler.MethodNotAllowedHandler(w, r)
   		}
   
   	case "/aaa":
   		switch r.Method {
   		case http.MethodGet:
   			handler.GetPost(w, r, userId, postId)
   		default:
   			handler.MethodNotAllowedHandler(w, r)
   		}
   
   	case "/bbb":
   		switch r.Method {
   		case http.MethodGet:
   			handler.GetPost(w, r, userId, postId)
   		default:
   			handler.MethodNotAllowedHandler(w, r)
   		}
   
   	default:
   		handler.NotFoundHandler(w, r)
   	}
   
   }
   
   func SeparatePath(p string, n int) (head, tail string) {
   	p = path.Clean("/" + p)
   	ps := strings.Split(p[1:], "/")
   	if len(ps) < n {
   		return p, ""
   	}
   	head = path.Clean("/" + strings.Join(ps[:n], "/"))
   	tail = path.Clean("/" + strings.Join(ps[n:], "/"))
   	return head, tail
   }
   ```
   
# Tips

`NewRouter` returns `http.Handler`. So you can use middleware func.






