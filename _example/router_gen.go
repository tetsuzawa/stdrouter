// Code generated by Standard Library Router Generator; DO NOT EDIT"

//go:generate stdrouter
//+build !stdrouter

package main

import (
	"github.com/tetsuzawa/stdrouter/_example/handler"
	"net/http"
	"path"
	"strings"
)

type Router struct{}

func NewRouter() http.Handler {
	r := &Router{}
	return r
}

func (router *Router) ServeHTTP(w http.ResponseWriter, r *http.Request) {
	handleBase(w, r, r.URL.Path)
}

func handleBase(w http.ResponseWriter, r *http.Request, p string) {
	endpoint, p := SeparatePath(p, 3)
	switch endpoint {
	case "/":
		switch r.Method {
		case http.MethodGet:
			handler.GetRoot(w, r)
		default:
			handler.MethodNotAllowedHandler(w, r)
		}

	case "/api":
		switch r.Method {
		case http.MethodGet:
			handler.GetAPIRoot(w, r)
		default:
			handler.MethodNotAllowedHandler(w, r)
		}

	case "/api/users":
		switch r.Method {
		case http.MethodGet:
			handler.GetUsers(w, r)
		default:
			handler.MethodNotAllowedHandler(w, r)
		}

	case "/api/products":
		switch r.Method {
		case http.MethodGet:
			handler.GetProducts(w, r)
		case http.MethodPost:
			handler.CreateProducts(w, r)
		default:
			handler.MethodNotAllowedHandler(w, r)
		}

	case "/api/users/create":
		switch r.Method {
		case http.MethodPost:
			handler.CreateUser(w, r)
		default:
			handler.MethodNotAllowedHandler(w, r)
		}

	default:
		endpoint, param := SeparatePath(endpoint, 2)
		if endpoint == "/api/users" {
			handleUserId(w, r, p, param[1:])
		} else {
			handler.NotFoundHandler(w, r)
		}

	}

}

func handleUserId(w http.ResponseWriter, r *http.Request, p string, userId string) {
	endpoint, p := SeparatePath(p, 2)
	switch endpoint {
	case "/":
		switch r.Method {
		case http.MethodGet:
			handler.GetUser(w, r, userId)
		case http.MethodPatch:
			handler.UpdateUser(w, r, userId)
		case http.MethodDelete:
			handler.DeleteUser(w, r, userId)
		default:
			handler.MethodNotAllowedHandler(w, r)
		}

	case "/posts":
		switch r.Method {
		case http.MethodGet:
			handler.GetPosts(w, r, userId)
		default:
			handler.MethodNotAllowedHandler(w, r)
		}

	case "/profile":
		switch r.Method {
		case http.MethodGet:
			handler.GetUser(w, r, userId)
		default:
			handler.MethodNotAllowedHandler(w, r)
		}

	default:
		endpoint, param := SeparatePath(endpoint, 1)
		if endpoint == "/posts" {
			handlePostId(w, r, p, userId, param[1:])
		} else {
			handler.NotFoundHandler(w, r)
		}

	}

}

func handlePostId(w http.ResponseWriter, r *http.Request, p string, userId string, postId string) {
	endpoint, p := SeparatePath(p, 2)
	switch endpoint {
	case "/":
		switch r.Method {
		case http.MethodGet:
			handler.GetPost(w, r, userId, postId)
		default:
			handler.MethodNotAllowedHandler(w, r)
		}

	case "/aaa":
		switch r.Method {
		case http.MethodGet:
			handler.GetPost(w, r, userId, postId)
		default:
			handler.MethodNotAllowedHandler(w, r)
		}

	case "/bbb":
		switch r.Method {
		case http.MethodGet:
			handler.GetPost(w, r, userId, postId)
		default:
			handler.MethodNotAllowedHandler(w, r)
		}

	default:
		handler.NotFoundHandler(w, r)
	}

}

func SeparatePath(p string, n int) (head, tail string) {
	p = path.Clean("/" + p)
	ps := strings.Split(p[1:], "/")
	if len(ps) < n {
		return p, ""
	}
	head = path.Clean("/" + strings.Join(ps[:n], "/"))
	tail = path.Clean("/" + strings.Join(ps[n:], "/"))
	return head, tail
}
